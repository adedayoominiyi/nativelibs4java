package com.nativelibs4java.opencl.library;
import com.nativelibs4java.opencl.library.IOpenCLLibrary.cl_GLsync;
import com.nativelibs4java.opencl.library.IOpenCLLibrary.cl_command_queue;
import com.nativelibs4java.opencl.library.IOpenCLLibrary.cl_context;
import com.nativelibs4java.opencl.library.IOpenCLLibrary.cl_device_id;
import com.nativelibs4java.opencl.library.IOpenCLLibrary.cl_event;
import com.nativelibs4java.opencl.library.IOpenCLLibrary.cl_kernel;
import com.nativelibs4java.opencl.library.IOpenCLLibrary.cl_mem;
import com.nativelibs4java.opencl.library.IOpenCLLibrary.cl_platform_id;
import com.nativelibs4java.opencl.library.IOpenCLLibrary.cl_program;
import com.nativelibs4java.opencl.library.IOpenCLLibrary.cl_sampler;
import org.bridj.CRuntime;
import org.bridj.Pointer;
import org.bridj.SizeT;
import org.bridj.ann.Library;
import org.bridj.ann.Optional;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
/**
 * Wrapper for library <b>OpenCL</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("OpenCL") 
@Runtime(CRuntime.class) 
public class OpenCLLibrary implements IOpenCLLibrary {
	/**
	 * Platform API<br>
	 * Original signature : <code>cl_int clGetPlatformIDs(cl_uint, cl_platform_id*, cl_uint*)</code>
	 */
	public int clGetPlatformIDs(int cl_uint1, Pointer<IOpenCLLibrary.cl_platform_id > cl_platform_idPtr1, Pointer<Integer > cl_uintPtr1) {
		return clGetPlatformIDs(cl_uint1, Pointer.getPeer(cl_platform_idPtr1), Pointer.getPeer(cl_uintPtr1));
	}
	public native int clGetPlatformIDs(int cl_uint1, @Ptr long cl_platform_idPtr1, @Ptr long cl_uintPtr1);
	/** Original signature : <code>cl_int clGetPlatformInfo(cl_platform_id, cl_platform_info, size_t, void*, size_t*)</code> */
	public int clGetPlatformInfo(IOpenCLLibrary.cl_platform_id cl_platform_id1, int cl_platform_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetPlatformInfo(Pointer.getPeer(cl_platform_id1), cl_platform_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetPlatformInfo(@Ptr long cl_platform_id1, int cl_platform_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/**
	 * Device APIs<br>
	 * Original signature : <code>cl_int clGetDeviceIDs(cl_platform_id, cl_device_type, cl_uint, cl_device_id*, cl_uint*)</code>
	 */
	public int clGetDeviceIDs(IOpenCLLibrary.cl_platform_id cl_platform_id1, long cl_device_type1, int cl_uint1, Pointer<IOpenCLLibrary.cl_device_id > cl_device_idPtr1, Pointer<Integer > cl_uintPtr1) {
		return clGetDeviceIDs(Pointer.getPeer(cl_platform_id1), cl_device_type1, cl_uint1, Pointer.getPeer(cl_device_idPtr1), Pointer.getPeer(cl_uintPtr1));
	}
	public native int clGetDeviceIDs(@Ptr long cl_platform_id1, long cl_device_type1, int cl_uint1, @Ptr long cl_device_idPtr1, @Ptr long cl_uintPtr1);
	/** Original signature : <code>cl_int clGetDeviceInfo(cl_device_id, cl_device_info, size_t, void*, size_t*)</code> */
	public int clGetDeviceInfo(IOpenCLLibrary.cl_device_id cl_device_id1, int cl_device_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetDeviceInfo(Pointer.getPeer(cl_device_id1), cl_device_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetDeviceInfo(@Ptr long cl_device_id1, int cl_device_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/** Original signature : <code>cl_int clCreateSubDevices(cl_device_id, const cl_device_partition_property*, cl_uint, cl_device_id*, cl_uint*)</code> */
	public int clCreateSubDevices(IOpenCLLibrary.cl_device_id cl_device_id1, Pointer<SizeT > cl_device_partition_propertyPtr1, int cl_uint1, Pointer<IOpenCLLibrary.cl_device_id > cl_device_idPtr1, Pointer<Integer > cl_uintPtr1) {
		return clCreateSubDevices(Pointer.getPeer(cl_device_id1), Pointer.getPeer(cl_device_partition_propertyPtr1), cl_uint1, Pointer.getPeer(cl_device_idPtr1), Pointer.getPeer(cl_uintPtr1));
	}
	@Optional 
	public native int clCreateSubDevices(@Ptr long cl_device_id1, @Ptr long cl_device_partition_propertyPtr1, int cl_uint1, @Ptr long cl_device_idPtr1, @Ptr long cl_uintPtr1);
	/** Original signature : <code>cl_int clRetainDevice(cl_device_id)</code> */
	public int clRetainDevice(IOpenCLLibrary.cl_device_id cl_device_id1) {
		return clRetainDevice(Pointer.getPeer(cl_device_id1));
	}
	@Optional 
	public native int clRetainDevice(@Ptr long cl_device_id1);
	/** Original signature : <code>cl_int clReleaseDevice(cl_device_id)</code> */
	public int clReleaseDevice(IOpenCLLibrary.cl_device_id cl_device_id1) {
		return clReleaseDevice(Pointer.getPeer(cl_device_id1));
	}
	@Optional 
	public native int clReleaseDevice(@Ptr long cl_device_id1);
	/**
	 * Context APIs<br>
	 * Original signature : <code>cl_context clCreateContext(const cl_context_properties*, cl_uint, const cl_device_id*, clCreateContext_arg1_callback*, void*, cl_int*)</code>
	 */
	public IOpenCLLibrary.cl_context clCreateContext(Pointer<SizeT > cl_context_propertiesPtr1, int cl_uint1, Pointer<IOpenCLLibrary.cl_device_id > cl_device_idPtr1, Pointer<OpenCLLibrary.clCreateContext_arg1_callback > arg1, Pointer<? > voidPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_context(clCreateContext(Pointer.getPeer(cl_context_propertiesPtr1), cl_uint1, Pointer.getPeer(cl_device_idPtr1), Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateContext(@Ptr long cl_context_propertiesPtr1, int cl_uint1, @Ptr long cl_device_idPtr1, @Ptr long arg1, @Ptr long voidPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_context clCreateContextFromType(const cl_context_properties*, cl_device_type, clCreateContextFromType_arg1_callback*, void*, cl_int*)</code> */
	public IOpenCLLibrary.cl_context clCreateContextFromType(Pointer<SizeT > cl_context_propertiesPtr1, long cl_device_type1, Pointer<OpenCLLibrary.clCreateContextFromType_arg1_callback > arg1, Pointer<? > voidPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_context(clCreateContextFromType(Pointer.getPeer(cl_context_propertiesPtr1), cl_device_type1, Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateContextFromType(@Ptr long cl_context_propertiesPtr1, long cl_device_type1, @Ptr long arg1, @Ptr long voidPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clRetainContext(cl_context)</code> */
	public int clRetainContext(IOpenCLLibrary.cl_context cl_context1) {
		return clRetainContext(Pointer.getPeer(cl_context1));
	}
	public native int clRetainContext(@Ptr long cl_context1);
	/** Original signature : <code>cl_int clReleaseContext(cl_context)</code> */
	public int clReleaseContext(IOpenCLLibrary.cl_context cl_context1) {
		return clReleaseContext(Pointer.getPeer(cl_context1));
	}
	public native int clReleaseContext(@Ptr long cl_context1);
	/** Original signature : <code>cl_int clGetContextInfo(cl_context, cl_context_info, size_t, void*, size_t*)</code> */
	public int clGetContextInfo(IOpenCLLibrary.cl_context cl_context1, int cl_context_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetContextInfo(Pointer.getPeer(cl_context1), cl_context_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetContextInfo(@Ptr long cl_context1, int cl_context_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/**
	 * Command Queue APIs<br>
	 * Original signature : <code>cl_command_queue clCreateCommandQueue(cl_context, cl_device_id, cl_command_queue_properties, cl_int*)</code>
	 */
	public IOpenCLLibrary.cl_command_queue clCreateCommandQueue(IOpenCLLibrary.cl_context cl_context1, IOpenCLLibrary.cl_device_id cl_device_id1, long cl_command_queue_properties1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_command_queue(clCreateCommandQueue(Pointer.getPeer(cl_context1), Pointer.getPeer(cl_device_id1), cl_command_queue_properties1, Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateCommandQueue(@Ptr long cl_context1, @Ptr long cl_device_id1, long cl_command_queue_properties1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clRetainCommandQueue(cl_command_queue)</code> */
	public int clRetainCommandQueue(IOpenCLLibrary.cl_command_queue cl_command_queue1) {
		return clRetainCommandQueue(Pointer.getPeer(cl_command_queue1));
	}
	public native int clRetainCommandQueue(@Ptr long cl_command_queue1);
	/** Original signature : <code>cl_int clReleaseCommandQueue(cl_command_queue)</code> */
	public int clReleaseCommandQueue(IOpenCLLibrary.cl_command_queue cl_command_queue1) {
		return clReleaseCommandQueue(Pointer.getPeer(cl_command_queue1));
	}
	public native int clReleaseCommandQueue(@Ptr long cl_command_queue1);
	/** Original signature : <code>cl_int clGetCommandQueueInfo(cl_command_queue, cl_command_queue_info, size_t, void*, size_t*)</code> */
	public int clGetCommandQueueInfo(IOpenCLLibrary.cl_command_queue cl_command_queue1, int cl_command_queue_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetCommandQueueInfo(Pointer.getPeer(cl_command_queue1), cl_command_queue_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetCommandQueueInfo(@Ptr long cl_command_queue1, int cl_command_queue_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/**
	 * Memory Object APIs<br>
	 * Original signature : <code>cl_mem clCreateBuffer(cl_context, cl_mem_flags, size_t, void*, cl_int*)</code>
	 */
	public IOpenCLLibrary.cl_mem clCreateBuffer(IOpenCLLibrary.cl_context cl_context1, long cl_mem_flags1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_mem(clCreateBuffer(Pointer.getPeer(cl_context1), cl_mem_flags1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateBuffer(@Ptr long cl_context1, long cl_mem_flags1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_mem clCreateSubBuffer(cl_mem, cl_mem_flags, cl_buffer_create_type, const void*, cl_int*)</code> */
	public IOpenCLLibrary.cl_mem clCreateSubBuffer(IOpenCLLibrary.cl_mem cl_mem1, long cl_mem_flags1, int cl_buffer_create_type1, Pointer<? > voidPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_mem(clCreateSubBuffer(Pointer.getPeer(cl_mem1), cl_mem_flags1, cl_buffer_create_type1, Pointer.getPeer(voidPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	@Optional 
	public native long clCreateSubBuffer(@Ptr long cl_mem1, long cl_mem_flags1, int cl_buffer_create_type1, @Ptr long voidPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_mem clCreateImage(cl_context, cl_mem_flags, const cl_image_format*, const cl_image_desc*, void*, cl_int*)</code> */
	public IOpenCLLibrary.cl_mem clCreateImage(IOpenCLLibrary.cl_context cl_context1, long cl_mem_flags1, Pointer<cl_image_format > cl_image_formatPtr1, Pointer<cl_image_desc > cl_image_descPtr1, Pointer<? > voidPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_mem(clCreateImage(Pointer.getPeer(cl_context1), cl_mem_flags1, Pointer.getPeer(cl_image_formatPtr1), Pointer.getPeer(cl_image_descPtr1), Pointer.getPeer(voidPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	@Optional 
	public native long clCreateImage(@Ptr long cl_context1, long cl_mem_flags1, @Ptr long cl_image_formatPtr1, @Ptr long cl_image_descPtr1, @Ptr long voidPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clRetainMemObject(cl_mem)</code> */
	public int clRetainMemObject(IOpenCLLibrary.cl_mem cl_mem1) {
		return clRetainMemObject(Pointer.getPeer(cl_mem1));
	}
	public native int clRetainMemObject(@Ptr long cl_mem1);
	/** Original signature : <code>cl_int clReleaseMemObject(cl_mem)</code> */
	public int clReleaseMemObject(IOpenCLLibrary.cl_mem cl_mem1) {
		return clReleaseMemObject(Pointer.getPeer(cl_mem1));
	}
	public native int clReleaseMemObject(@Ptr long cl_mem1);
	/** Original signature : <code>cl_int clGetSupportedImageFormats(cl_context, cl_mem_flags, cl_mem_object_type, cl_uint, cl_image_format*, cl_uint*)</code> */
	public int clGetSupportedImageFormats(IOpenCLLibrary.cl_context cl_context1, long cl_mem_flags1, int cl_mem_object_type1, int cl_uint1, Pointer<cl_image_format > cl_image_formatPtr1, Pointer<Integer > cl_uintPtr1) {
		return clGetSupportedImageFormats(Pointer.getPeer(cl_context1), cl_mem_flags1, cl_mem_object_type1, cl_uint1, Pointer.getPeer(cl_image_formatPtr1), Pointer.getPeer(cl_uintPtr1));
	}
	public native int clGetSupportedImageFormats(@Ptr long cl_context1, long cl_mem_flags1, int cl_mem_object_type1, int cl_uint1, @Ptr long cl_image_formatPtr1, @Ptr long cl_uintPtr1);
	/** Original signature : <code>cl_int clGetMemObjectInfo(cl_mem, cl_mem_info, size_t, void*, size_t*)</code> */
	public int clGetMemObjectInfo(IOpenCLLibrary.cl_mem cl_mem1, int cl_mem_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetMemObjectInfo(Pointer.getPeer(cl_mem1), cl_mem_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetMemObjectInfo(@Ptr long cl_mem1, int cl_mem_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/** Original signature : <code>cl_int clGetImageInfo(cl_mem, cl_image_info, size_t, void*, size_t*)</code> */
	public int clGetImageInfo(IOpenCLLibrary.cl_mem cl_mem1, int cl_image_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetImageInfo(Pointer.getPeer(cl_mem1), cl_image_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetImageInfo(@Ptr long cl_mem1, int cl_image_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/** Original signature : <code>cl_int clSetMemObjectDestructorCallback(cl_mem, clSetMemObjectDestructorCallback_arg1_callback*, void*)</code> */
	public int clSetMemObjectDestructorCallback(IOpenCLLibrary.cl_mem cl_mem1, Pointer<OpenCLLibrary.clSetMemObjectDestructorCallback_arg1_callback > arg1, Pointer<? > voidPtr1) {
		return clSetMemObjectDestructorCallback(Pointer.getPeer(cl_mem1), Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1));
	}
	@Optional 
	public native int clSetMemObjectDestructorCallback(@Ptr long cl_mem1, @Ptr long arg1, @Ptr long voidPtr1);
	/**
	 * Sampler APIs<br>
	 * Original signature : <code>cl_sampler clCreateSampler(cl_context, cl_bool, cl_addressing_mode, cl_filter_mode, cl_int*)</code>
	 */
	public IOpenCLLibrary.cl_sampler clCreateSampler(IOpenCLLibrary.cl_context cl_context1, int cl_bool1, int cl_addressing_mode1, int cl_filter_mode1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_sampler(clCreateSampler(Pointer.getPeer(cl_context1), cl_bool1, cl_addressing_mode1, cl_filter_mode1, Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateSampler(@Ptr long cl_context1, int cl_bool1, int cl_addressing_mode1, int cl_filter_mode1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clRetainSampler(cl_sampler)</code> */
	public int clRetainSampler(IOpenCLLibrary.cl_sampler cl_sampler1) {
		return clRetainSampler(Pointer.getPeer(cl_sampler1));
	}
	public native int clRetainSampler(@Ptr long cl_sampler1);
	/** Original signature : <code>cl_int clReleaseSampler(cl_sampler)</code> */
	public int clReleaseSampler(IOpenCLLibrary.cl_sampler cl_sampler1) {
		return clReleaseSampler(Pointer.getPeer(cl_sampler1));
	}
	public native int clReleaseSampler(@Ptr long cl_sampler1);
	/** Original signature : <code>cl_int clGetSamplerInfo(cl_sampler, cl_sampler_info, size_t, void*, size_t*)</code> */
	public int clGetSamplerInfo(IOpenCLLibrary.cl_sampler cl_sampler1, int cl_sampler_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetSamplerInfo(Pointer.getPeer(cl_sampler1), cl_sampler_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetSamplerInfo(@Ptr long cl_sampler1, int cl_sampler_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/**
	 * Program Object APIs<br>
	 * Original signature : <code>cl_program clCreateProgramWithSource(cl_context, cl_uint, const char**, const size_t*, cl_int*)</code>
	 */
	public IOpenCLLibrary.cl_program clCreateProgramWithSource(IOpenCLLibrary.cl_context cl_context1, int cl_uint1, Pointer<Pointer<Byte > > charPtrPtr1, Pointer<SizeT > size_tPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_program(clCreateProgramWithSource(Pointer.getPeer(cl_context1), cl_uint1, Pointer.getPeer(charPtrPtr1), Pointer.getPeer(size_tPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateProgramWithSource(@Ptr long cl_context1, int cl_uint1, @Ptr long charPtrPtr1, @Ptr long size_tPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_program clCreateProgramWithBinary(cl_context, cl_uint, const cl_device_id*, const size_t*, const unsigned char**, cl_int*, cl_int*)</code> */
	public IOpenCLLibrary.cl_program clCreateProgramWithBinary(IOpenCLLibrary.cl_context cl_context1, int cl_uint1, Pointer<IOpenCLLibrary.cl_device_id > cl_device_idPtr1, Pointer<SizeT > size_tPtr1, Pointer<Pointer<Byte > > charPtrPtr1, Pointer<Integer > cl_intPtr1, Pointer<Integer > cl_intPtr2) {
		return new IOpenCLLibrary.cl_program(clCreateProgramWithBinary(Pointer.getPeer(cl_context1), cl_uint1, Pointer.getPeer(cl_device_idPtr1), Pointer.getPeer(size_tPtr1), Pointer.getPeer(charPtrPtr1), Pointer.getPeer(cl_intPtr1), Pointer.getPeer(cl_intPtr2)));
	}
	@Ptr 
	public native long clCreateProgramWithBinary(@Ptr long cl_context1, int cl_uint1, @Ptr long cl_device_idPtr1, @Ptr long size_tPtr1, @Ptr long charPtrPtr1, @Ptr long cl_intPtr1, @Ptr long cl_intPtr2);
	/** Original signature : <code>cl_program clCreateProgramWithBuiltInKernels(cl_context, cl_uint, const cl_device_id*, const char*, cl_int*)</code> */
	public IOpenCLLibrary.cl_program clCreateProgramWithBuiltInKernels(IOpenCLLibrary.cl_context cl_context1, int cl_uint1, Pointer<IOpenCLLibrary.cl_device_id > cl_device_idPtr1, Pointer<Byte > charPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_program(clCreateProgramWithBuiltInKernels(Pointer.getPeer(cl_context1), cl_uint1, Pointer.getPeer(cl_device_idPtr1), Pointer.getPeer(charPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	@Optional 
	public native long clCreateProgramWithBuiltInKernels(@Ptr long cl_context1, int cl_uint1, @Ptr long cl_device_idPtr1, @Ptr long charPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clRetainProgram(cl_program)</code> */
	public int clRetainProgram(IOpenCLLibrary.cl_program cl_program1) {
		return clRetainProgram(Pointer.getPeer(cl_program1));
	}
	public native int clRetainProgram(@Ptr long cl_program1);
	/** Original signature : <code>cl_int clReleaseProgram(cl_program)</code> */
	public int clReleaseProgram(IOpenCLLibrary.cl_program cl_program1) {
		return clReleaseProgram(Pointer.getPeer(cl_program1));
	}
	public native int clReleaseProgram(@Ptr long cl_program1);
	/** Original signature : <code>cl_int clBuildProgram(cl_program, cl_uint, const cl_device_id*, const char*, clBuildProgram_arg1_callback*, void*)</code> */
	public int clBuildProgram(IOpenCLLibrary.cl_program cl_program1, int cl_uint1, Pointer<IOpenCLLibrary.cl_device_id > cl_device_idPtr1, Pointer<Byte > charPtr1, Pointer<OpenCLLibrary.clBuildProgram_arg1_callback > arg1, Pointer<? > voidPtr1) {
		return clBuildProgram(Pointer.getPeer(cl_program1), cl_uint1, Pointer.getPeer(cl_device_idPtr1), Pointer.getPeer(charPtr1), Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1));
	}
	public native int clBuildProgram(@Ptr long cl_program1, int cl_uint1, @Ptr long cl_device_idPtr1, @Ptr long charPtr1, @Ptr long arg1, @Ptr long voidPtr1);
	/** Original signature : <code>cl_int clCompileProgram(cl_program, cl_uint, const cl_device_id*, const char*, cl_uint, const cl_program*, const char**, clCompileProgram_arg1_callback*, void*)</code> */
	public int clCompileProgram(IOpenCLLibrary.cl_program cl_program1, int cl_uint1, Pointer<IOpenCLLibrary.cl_device_id > cl_device_idPtr1, Pointer<Byte > charPtr1, int cl_uint2, Pointer<IOpenCLLibrary.cl_program > cl_programPtr1, Pointer<Pointer<Byte > > charPtrPtr1, Pointer<OpenCLLibrary.clCompileProgram_arg1_callback > arg1, Pointer<? > voidPtr1) {
		return clCompileProgram(Pointer.getPeer(cl_program1), cl_uint1, Pointer.getPeer(cl_device_idPtr1), Pointer.getPeer(charPtr1), cl_uint2, Pointer.getPeer(cl_programPtr1), Pointer.getPeer(charPtrPtr1), Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1));
	}
	@Optional 
	public native int clCompileProgram(@Ptr long cl_program1, int cl_uint1, @Ptr long cl_device_idPtr1, @Ptr long charPtr1, int cl_uint2, @Ptr long cl_programPtr1, @Ptr long charPtrPtr1, @Ptr long arg1, @Ptr long voidPtr1);
	/** Original signature : <code>cl_program clLinkProgram(cl_context, cl_uint, const cl_device_id*, const char*, cl_uint, const cl_program*, clLinkProgram_arg1_callback*, void*, cl_int*)</code> */
	public IOpenCLLibrary.cl_program clLinkProgram(IOpenCLLibrary.cl_context cl_context1, int cl_uint1, Pointer<IOpenCLLibrary.cl_device_id > cl_device_idPtr1, Pointer<Byte > charPtr1, int cl_uint2, Pointer<IOpenCLLibrary.cl_program > cl_programPtr1, Pointer<OpenCLLibrary.clLinkProgram_arg1_callback > arg1, Pointer<? > voidPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_program(clLinkProgram(Pointer.getPeer(cl_context1), cl_uint1, Pointer.getPeer(cl_device_idPtr1), Pointer.getPeer(charPtr1), cl_uint2, Pointer.getPeer(cl_programPtr1), Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	@Optional 
	public native long clLinkProgram(@Ptr long cl_context1, int cl_uint1, @Ptr long cl_device_idPtr1, @Ptr long charPtr1, int cl_uint2, @Ptr long cl_programPtr1, @Ptr long arg1, @Ptr long voidPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clUnloadPlatformCompiler(cl_platform_id)</code> */
	public int clUnloadPlatformCompiler(IOpenCLLibrary.cl_platform_id cl_platform_id1) {
		return clUnloadPlatformCompiler(Pointer.getPeer(cl_platform_id1));
	}
	@Optional 
	public native int clUnloadPlatformCompiler(@Ptr long cl_platform_id1);
	/** Original signature : <code>cl_int clGetProgramInfo(cl_program, cl_program_info, size_t, void*, size_t*)</code> */
	public int clGetProgramInfo(IOpenCLLibrary.cl_program cl_program1, int cl_program_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetProgramInfo(Pointer.getPeer(cl_program1), cl_program_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetProgramInfo(@Ptr long cl_program1, int cl_program_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/** Original signature : <code>cl_int clGetProgramBuildInfo(cl_program, cl_device_id, cl_program_build_info, size_t, void*, size_t*)</code> */
	public int clGetProgramBuildInfo(IOpenCLLibrary.cl_program cl_program1, IOpenCLLibrary.cl_device_id cl_device_id1, int cl_program_build_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetProgramBuildInfo(Pointer.getPeer(cl_program1), Pointer.getPeer(cl_device_id1), cl_program_build_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetProgramBuildInfo(@Ptr long cl_program1, @Ptr long cl_device_id1, int cl_program_build_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/**
	 * Kernel Object APIs<br>
	 * Original signature : <code>cl_kernel clCreateKernel(cl_program, const char*, cl_int*)</code>
	 */
	public IOpenCLLibrary.cl_kernel clCreateKernel(IOpenCLLibrary.cl_program cl_program1, Pointer<Byte > charPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_kernel(clCreateKernel(Pointer.getPeer(cl_program1), Pointer.getPeer(charPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateKernel(@Ptr long cl_program1, @Ptr long charPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clCreateKernelsInProgram(cl_program, cl_uint, cl_kernel*, cl_uint*)</code> */
	public int clCreateKernelsInProgram(IOpenCLLibrary.cl_program cl_program1, int cl_uint1, Pointer<IOpenCLLibrary.cl_kernel > cl_kernelPtr1, Pointer<Integer > cl_uintPtr1) {
		return clCreateKernelsInProgram(Pointer.getPeer(cl_program1), cl_uint1, Pointer.getPeer(cl_kernelPtr1), Pointer.getPeer(cl_uintPtr1));
	}
	public native int clCreateKernelsInProgram(@Ptr long cl_program1, int cl_uint1, @Ptr long cl_kernelPtr1, @Ptr long cl_uintPtr1);
	/** Original signature : <code>cl_int clRetainKernel(cl_kernel)</code> */
	public int clRetainKernel(IOpenCLLibrary.cl_kernel cl_kernel1) {
		return clRetainKernel(Pointer.getPeer(cl_kernel1));
	}
	public native int clRetainKernel(@Ptr long cl_kernel1);
	/** Original signature : <code>cl_int clReleaseKernel(cl_kernel)</code> */
	public int clReleaseKernel(IOpenCLLibrary.cl_kernel cl_kernel1) {
		return clReleaseKernel(Pointer.getPeer(cl_kernel1));
	}
	public native int clReleaseKernel(@Ptr long cl_kernel1);
	/** Original signature : <code>cl_int clSetKernelArg(cl_kernel, cl_uint, size_t, const void*)</code> */
	public int clSetKernelArg(IOpenCLLibrary.cl_kernel cl_kernel1, int cl_uint1, @Ptr long size_t1, Pointer<? > voidPtr1) {
		return clSetKernelArg(Pointer.getPeer(cl_kernel1), cl_uint1, size_t1, Pointer.getPeer(voidPtr1));
	}
	public native int clSetKernelArg(@Ptr long cl_kernel1, int cl_uint1, @Ptr long size_t1, @Ptr long voidPtr1);
	/** Original signature : <code>cl_int clGetKernelInfo(cl_kernel, cl_kernel_info, size_t, void*, size_t*)</code> */
	public int clGetKernelInfo(IOpenCLLibrary.cl_kernel cl_kernel1, int cl_kernel_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetKernelInfo(Pointer.getPeer(cl_kernel1), cl_kernel_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetKernelInfo(@Ptr long cl_kernel1, int cl_kernel_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/** Original signature : <code>cl_int clGetKernelArgInfo(cl_kernel, cl_uint, cl_kernel_arg_info, size_t, void*, size_t*)</code> */
	public int clGetKernelArgInfo(IOpenCLLibrary.cl_kernel cl_kernel1, int cl_uint1, int cl_kernel_arg_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetKernelArgInfo(Pointer.getPeer(cl_kernel1), cl_uint1, cl_kernel_arg_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	@Optional 
	public native int clGetKernelArgInfo(@Ptr long cl_kernel1, int cl_uint1, int cl_kernel_arg_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/** Original signature : <code>cl_int clGetKernelWorkGroupInfo(cl_kernel, cl_device_id, cl_kernel_work_group_info, size_t, void*, size_t*)</code> */
	public int clGetKernelWorkGroupInfo(IOpenCLLibrary.cl_kernel cl_kernel1, IOpenCLLibrary.cl_device_id cl_device_id1, int cl_kernel_work_group_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetKernelWorkGroupInfo(Pointer.getPeer(cl_kernel1), Pointer.getPeer(cl_device_id1), cl_kernel_work_group_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetKernelWorkGroupInfo(@Ptr long cl_kernel1, @Ptr long cl_device_id1, int cl_kernel_work_group_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/**
	 * Event Object APIs<br>
	 * Original signature : <code>cl_int clWaitForEvents(cl_uint, const cl_event*)</code>
	 */
	public int clWaitForEvents(int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1) {
		return clWaitForEvents(cl_uint1, Pointer.getPeer(cl_eventPtr1));
	}
	public native int clWaitForEvents(int cl_uint1, @Ptr long cl_eventPtr1);
	/** Original signature : <code>cl_int clGetEventInfo(cl_event, cl_event_info, size_t, void*, size_t*)</code> */
	public int clGetEventInfo(IOpenCLLibrary.cl_event cl_event1, int cl_event_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetEventInfo(Pointer.getPeer(cl_event1), cl_event_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetEventInfo(@Ptr long cl_event1, int cl_event_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/** Original signature : <code>cl_event clCreateUserEvent(cl_context, cl_int*)</code> */
	public IOpenCLLibrary.cl_event clCreateUserEvent(IOpenCLLibrary.cl_context cl_context1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_event(clCreateUserEvent(Pointer.getPeer(cl_context1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	@Optional 
	public native long clCreateUserEvent(@Ptr long cl_context1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clRetainEvent(cl_event)</code> */
	public int clRetainEvent(IOpenCLLibrary.cl_event cl_event1) {
		return clRetainEvent(Pointer.getPeer(cl_event1));
	}
	public native int clRetainEvent(@Ptr long cl_event1);
	/** Original signature : <code>cl_int clReleaseEvent(cl_event)</code> */
	public int clReleaseEvent(IOpenCLLibrary.cl_event cl_event1) {
		return clReleaseEvent(Pointer.getPeer(cl_event1));
	}
	public native int clReleaseEvent(@Ptr long cl_event1);
	/** Original signature : <code>cl_int clSetUserEventStatus(cl_event, cl_int)</code> */
	public int clSetUserEventStatus(IOpenCLLibrary.cl_event cl_event1, int cl_int1) {
		return clSetUserEventStatus(Pointer.getPeer(cl_event1), cl_int1);
	}
	@Optional 
	public native int clSetUserEventStatus(@Ptr long cl_event1, int cl_int1);
	/** Original signature : <code>cl_int clSetEventCallback(cl_event, cl_int, clSetEventCallback_arg1_callback*, void*)</code> */
	public int clSetEventCallback(IOpenCLLibrary.cl_event cl_event1, int cl_int1, Pointer<OpenCLLibrary.clSetEventCallback_arg1_callback > arg1, Pointer<? > voidPtr1) {
		return clSetEventCallback(Pointer.getPeer(cl_event1), cl_int1, Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1));
	}
	@Optional 
	public native int clSetEventCallback(@Ptr long cl_event1, int cl_int1, @Ptr long arg1, @Ptr long voidPtr1);
	/**
	 * Profiling APIs<br>
	 * Original signature : <code>cl_int clGetEventProfilingInfo(cl_event, cl_profiling_info, size_t, void*, size_t*)</code>
	 */
	public int clGetEventProfilingInfo(IOpenCLLibrary.cl_event cl_event1, int cl_profiling_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetEventProfilingInfo(Pointer.getPeer(cl_event1), cl_profiling_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetEventProfilingInfo(@Ptr long cl_event1, int cl_profiling_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/**
	 * Flush and Finish APIs<br>
	 * Original signature : <code>cl_int clFlush(cl_command_queue)</code>
	 */
	public int clFlush(IOpenCLLibrary.cl_command_queue cl_command_queue1) {
		return clFlush(Pointer.getPeer(cl_command_queue1));
	}
	public native int clFlush(@Ptr long cl_command_queue1);
	/** Original signature : <code>cl_int clFinish(cl_command_queue)</code> */
	public int clFinish(IOpenCLLibrary.cl_command_queue cl_command_queue1) {
		return clFinish(Pointer.getPeer(cl_command_queue1));
	}
	public native int clFinish(@Ptr long cl_command_queue1);
	/**
	 * Enqueued Commands APIs<br>
	 * Original signature : <code>cl_int clEnqueueReadBuffer(cl_command_queue, cl_mem, cl_bool, size_t, size_t, void*, cl_uint, const cl_event*, cl_event*)</code>
	 */
	public int clEnqueueReadBuffer(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, int cl_bool1, @Ptr long size_t1, @Ptr long size_t2, Pointer<? > voidPtr1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueReadBuffer(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), cl_bool1, size_t1, size_t2, Pointer.getPeer(voidPtr1), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueReadBuffer(@Ptr long cl_command_queue1, @Ptr long cl_mem1, int cl_bool1, @Ptr long size_t1, @Ptr long size_t2, @Ptr long voidPtr1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueReadBufferRect(cl_command_queue, cl_mem, cl_bool, const size_t*, const size_t*, const size_t*, size_t, size_t, size_t, size_t, void*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueReadBufferRect(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, int cl_bool1, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, Pointer<SizeT > size_tPtr3, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, @Ptr long size_t4, Pointer<? > voidPtr1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueReadBufferRect(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), cl_bool1, Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), Pointer.getPeer(size_tPtr3), size_t1, size_t2, size_t3, size_t4, Pointer.getPeer(voidPtr1), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	@Optional 
	public native int clEnqueueReadBufferRect(@Ptr long cl_command_queue1, @Ptr long cl_mem1, int cl_bool1, @Ptr long size_tPtr1, @Ptr long size_tPtr2, @Ptr long size_tPtr3, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, @Ptr long size_t4, @Ptr long voidPtr1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueWriteBuffer(cl_command_queue, cl_mem, cl_bool, size_t, size_t, const void*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueWriteBuffer(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, int cl_bool1, @Ptr long size_t1, @Ptr long size_t2, Pointer<? > voidPtr1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueWriteBuffer(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), cl_bool1, size_t1, size_t2, Pointer.getPeer(voidPtr1), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueWriteBuffer(@Ptr long cl_command_queue1, @Ptr long cl_mem1, int cl_bool1, @Ptr long size_t1, @Ptr long size_t2, @Ptr long voidPtr1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueWriteBufferRect(cl_command_queue, cl_mem, cl_bool, const size_t*, const size_t*, const size_t*, size_t, size_t, size_t, size_t, const void*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueWriteBufferRect(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, int cl_bool1, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, Pointer<SizeT > size_tPtr3, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, @Ptr long size_t4, Pointer<? > voidPtr1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueWriteBufferRect(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), cl_bool1, Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), Pointer.getPeer(size_tPtr3), size_t1, size_t2, size_t3, size_t4, Pointer.getPeer(voidPtr1), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	@Optional 
	public native int clEnqueueWriteBufferRect(@Ptr long cl_command_queue1, @Ptr long cl_mem1, int cl_bool1, @Ptr long size_tPtr1, @Ptr long size_tPtr2, @Ptr long size_tPtr3, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, @Ptr long size_t4, @Ptr long voidPtr1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueFillBuffer(cl_command_queue, cl_mem, const void*, size_t, size_t, size_t, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueFillBuffer(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, Pointer<? > voidPtr1, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueFillBuffer(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), Pointer.getPeer(voidPtr1), size_t1, size_t2, size_t3, cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	@Optional 
	public native int clEnqueueFillBuffer(@Ptr long cl_command_queue1, @Ptr long cl_mem1, @Ptr long voidPtr1, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueCopyBuffer(cl_command_queue, cl_mem, cl_mem, size_t, size_t, size_t, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueCopyBuffer(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, IOpenCLLibrary.cl_mem cl_mem2, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueCopyBuffer(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), Pointer.getPeer(cl_mem2), size_t1, size_t2, size_t3, cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueCopyBuffer(@Ptr long cl_command_queue1, @Ptr long cl_mem1, @Ptr long cl_mem2, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueCopyBufferRect(cl_command_queue, cl_mem, cl_mem, const size_t*, const size_t*, const size_t*, size_t, size_t, size_t, size_t, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueCopyBufferRect(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, IOpenCLLibrary.cl_mem cl_mem2, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, Pointer<SizeT > size_tPtr3, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, @Ptr long size_t4, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueCopyBufferRect(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), Pointer.getPeer(cl_mem2), Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), Pointer.getPeer(size_tPtr3), size_t1, size_t2, size_t3, size_t4, cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	@Optional 
	public native int clEnqueueCopyBufferRect(@Ptr long cl_command_queue1, @Ptr long cl_mem1, @Ptr long cl_mem2, @Ptr long size_tPtr1, @Ptr long size_tPtr2, @Ptr long size_tPtr3, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, @Ptr long size_t4, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueReadImage(cl_command_queue, cl_mem, cl_bool, const size_t*, const size_t*, size_t, size_t, void*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueReadImage(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, int cl_bool1, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, @Ptr long size_t1, @Ptr long size_t2, Pointer<? > voidPtr1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueReadImage(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), cl_bool1, Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), size_t1, size_t2, Pointer.getPeer(voidPtr1), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueReadImage(@Ptr long cl_command_queue1, @Ptr long cl_mem1, int cl_bool1, @Ptr long size_tPtr1, @Ptr long size_tPtr2, @Ptr long size_t1, @Ptr long size_t2, @Ptr long voidPtr1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueWriteImage(cl_command_queue, cl_mem, cl_bool, const size_t*, const size_t*, size_t, size_t, const void*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueWriteImage(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, int cl_bool1, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, @Ptr long size_t1, @Ptr long size_t2, Pointer<? > voidPtr1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueWriteImage(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), cl_bool1, Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), size_t1, size_t2, Pointer.getPeer(voidPtr1), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueWriteImage(@Ptr long cl_command_queue1, @Ptr long cl_mem1, int cl_bool1, @Ptr long size_tPtr1, @Ptr long size_tPtr2, @Ptr long size_t1, @Ptr long size_t2, @Ptr long voidPtr1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueFillImage(cl_command_queue, cl_mem, const void*, const size_t*, const size_t*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueFillImage(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueFillImage(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	@Optional 
	public native int clEnqueueFillImage(@Ptr long cl_command_queue1, @Ptr long cl_mem1, @Ptr long voidPtr1, @Ptr long size_tPtr1, @Ptr long size_tPtr2, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueCopyImage(cl_command_queue, cl_mem, cl_mem, const size_t*, const size_t*, const size_t*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueCopyImage(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, IOpenCLLibrary.cl_mem cl_mem2, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, Pointer<SizeT > size_tPtr3, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueCopyImage(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), Pointer.getPeer(cl_mem2), Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), Pointer.getPeer(size_tPtr3), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueCopyImage(@Ptr long cl_command_queue1, @Ptr long cl_mem1, @Ptr long cl_mem2, @Ptr long size_tPtr1, @Ptr long size_tPtr2, @Ptr long size_tPtr3, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueCopyImageToBuffer(cl_command_queue, cl_mem, cl_mem, const size_t*, const size_t*, size_t, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueCopyImageToBuffer(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, IOpenCLLibrary.cl_mem cl_mem2, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, @Ptr long size_t1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueCopyImageToBuffer(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), Pointer.getPeer(cl_mem2), Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), size_t1, cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueCopyImageToBuffer(@Ptr long cl_command_queue1, @Ptr long cl_mem1, @Ptr long cl_mem2, @Ptr long size_tPtr1, @Ptr long size_tPtr2, @Ptr long size_t1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueCopyBufferToImage(cl_command_queue, cl_mem, cl_mem, size_t, const size_t*, const size_t*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueCopyBufferToImage(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, IOpenCLLibrary.cl_mem cl_mem2, @Ptr long size_t1, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueCopyBufferToImage(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), Pointer.getPeer(cl_mem2), size_t1, Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueCopyBufferToImage(@Ptr long cl_command_queue1, @Ptr long cl_mem1, @Ptr long cl_mem2, @Ptr long size_t1, @Ptr long size_tPtr1, @Ptr long size_tPtr2, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>void* clEnqueueMapBuffer(cl_command_queue, cl_mem, cl_bool, cl_map_flags, size_t, size_t, cl_uint, const cl_event*, cl_event*, cl_int*)</code> */
	public Pointer<? > clEnqueueMapBuffer(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, int cl_bool1, long cl_map_flags1, @Ptr long size_t1, @Ptr long size_t2, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2, Pointer<Integer > cl_intPtr1) {
		return Pointer.pointerToAddress(clEnqueueMapBuffer(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), cl_bool1, cl_map_flags1, size_t1, size_t2, cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clEnqueueMapBuffer(@Ptr long cl_command_queue1, @Ptr long cl_mem1, int cl_bool1, long cl_map_flags1, @Ptr long size_t1, @Ptr long size_t2, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2, @Ptr long cl_intPtr1);
	/** Original signature : <code>void* clEnqueueMapImage(cl_command_queue, cl_mem, cl_bool, cl_map_flags, const size_t*, const size_t*, size_t*, size_t*, cl_uint, const cl_event*, cl_event*, cl_int*)</code> */
	public Pointer<? > clEnqueueMapImage(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, int cl_bool1, long cl_map_flags1, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, Pointer<SizeT > size_tPtr3, Pointer<SizeT > size_tPtr4, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2, Pointer<Integer > cl_intPtr1) {
		return Pointer.pointerToAddress(clEnqueueMapImage(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), cl_bool1, cl_map_flags1, Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), Pointer.getPeer(size_tPtr3), Pointer.getPeer(size_tPtr4), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clEnqueueMapImage(@Ptr long cl_command_queue1, @Ptr long cl_mem1, int cl_bool1, long cl_map_flags1, @Ptr long size_tPtr1, @Ptr long size_tPtr2, @Ptr long size_tPtr3, @Ptr long size_tPtr4, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clEnqueueUnmapMemObject(cl_command_queue, cl_mem, void*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueUnmapMemObject(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_mem cl_mem1, Pointer<? > voidPtr1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueUnmapMemObject(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_mem1), Pointer.getPeer(voidPtr1), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueUnmapMemObject(@Ptr long cl_command_queue1, @Ptr long cl_mem1, @Ptr long voidPtr1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueMigrateMemObjects(cl_command_queue, cl_uint, const cl_mem*, cl_mem_migration_flags, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueMigrateMemObjects(IOpenCLLibrary.cl_command_queue cl_command_queue1, int cl_uint1, Pointer<IOpenCLLibrary.cl_mem > cl_memPtr1, long cl_mem_migration_flags1, int cl_uint2, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueMigrateMemObjects(Pointer.getPeer(cl_command_queue1), cl_uint1, Pointer.getPeer(cl_memPtr1), cl_mem_migration_flags1, cl_uint2, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	@Optional 
	public native int clEnqueueMigrateMemObjects(@Ptr long cl_command_queue1, int cl_uint1, @Ptr long cl_memPtr1, long cl_mem_migration_flags1, int cl_uint2, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueNDRangeKernel(cl_command_queue, cl_kernel, cl_uint, const size_t*, const size_t*, const size_t*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueNDRangeKernel(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_kernel cl_kernel1, int cl_uint1, Pointer<SizeT > size_tPtr1, Pointer<SizeT > size_tPtr2, Pointer<SizeT > size_tPtr3, int cl_uint2, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueNDRangeKernel(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_kernel1), cl_uint1, Pointer.getPeer(size_tPtr1), Pointer.getPeer(size_tPtr2), Pointer.getPeer(size_tPtr3), cl_uint2, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueNDRangeKernel(@Ptr long cl_command_queue1, @Ptr long cl_kernel1, int cl_uint1, @Ptr long size_tPtr1, @Ptr long size_tPtr2, @Ptr long size_tPtr3, int cl_uint2, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueTask(cl_command_queue, cl_kernel, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueTask(IOpenCLLibrary.cl_command_queue cl_command_queue1, IOpenCLLibrary.cl_kernel cl_kernel1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueTask(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_kernel1), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueTask(@Ptr long cl_command_queue1, @Ptr long cl_kernel1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueNativeKernel(cl_command_queue, clEnqueueNativeKernel_arg1_callback*, void*, size_t, cl_uint, const cl_mem*, const void**, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueNativeKernel(IOpenCLLibrary.cl_command_queue cl_command_queue1, Pointer<OpenCLLibrary.clEnqueueNativeKernel_arg1_callback > arg1, Pointer<? > voidPtr1, @Ptr long size_t1, int cl_uint1, Pointer<IOpenCLLibrary.cl_mem > cl_memPtr1, Pointer<Pointer<? > > voidPtrPtr1, int cl_uint2, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueNativeKernel(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1), size_t1, cl_uint1, Pointer.getPeer(cl_memPtr1), Pointer.getPeer(voidPtrPtr1), cl_uint2, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueNativeKernel(@Ptr long cl_command_queue1, @Ptr long arg1, @Ptr long voidPtr1, @Ptr long size_t1, int cl_uint1, @Ptr long cl_memPtr1, @Ptr long voidPtrPtr1, int cl_uint2, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueMarkerWithWaitList(cl_command_queue, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueMarkerWithWaitList(IOpenCLLibrary.cl_command_queue cl_command_queue1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueMarkerWithWaitList(Pointer.getPeer(cl_command_queue1), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	@Optional 
	public native int clEnqueueMarkerWithWaitList(@Ptr long cl_command_queue1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueBarrierWithWaitList(cl_command_queue, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueBarrierWithWaitList(IOpenCLLibrary.cl_command_queue cl_command_queue1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueBarrierWithWaitList(Pointer.getPeer(cl_command_queue1), cl_uint1, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	@Optional 
	public native int clEnqueueBarrierWithWaitList(@Ptr long cl_command_queue1, int cl_uint1, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clSetPrintfCallback(cl_context, clSetPrintfCallback_arg1_callback*, void*)</code> */
	public int clSetPrintfCallback(IOpenCLLibrary.cl_context cl_context1, Pointer<OpenCLLibrary.clSetPrintfCallback_arg1_callback > arg1, Pointer<? > voidPtr1) {
		return clSetPrintfCallback(Pointer.getPeer(cl_context1), Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1));
	}
	@Optional 
	public native int clSetPrintfCallback(@Ptr long cl_context1, @Ptr long arg1, @Ptr long voidPtr1);
	/**
	 * Extension function access<br>
	 * Returns the extension function address for the given function name,<br>
	 * or NULL if a valid function can not be found.  The client must<br>
	 * check to make sure the address is not NULL, before using or <br>
	 * calling the returned function address.<br>
	 * Original signature : <code>void* clGetExtensionFunctionAddressForPlatform(cl_platform_id, const char*)</code>
	 */
	public Pointer<? > clGetExtensionFunctionAddressForPlatform(IOpenCLLibrary.cl_platform_id cl_platform_id1, Pointer<Byte > charPtr1) {
		return Pointer.pointerToAddress(clGetExtensionFunctionAddressForPlatform(Pointer.getPeer(cl_platform_id1), Pointer.getPeer(charPtr1)));
	}
	@Ptr 
	@Optional 
	public native long clGetExtensionFunctionAddressForPlatform(@Ptr long cl_platform_id1, @Ptr long charPtr1);
	/** Original signature : <code>cl_int clSetCommandQueueProperty(cl_command_queue, cl_command_queue_properties, cl_bool, cl_command_queue_properties*)</code> */
	public int clSetCommandQueueProperty(IOpenCLLibrary.cl_command_queue cl_command_queue1, long cl_command_queue_properties1, int cl_bool1, Pointer<Long > cl_command_queue_propertiesPtr1) {
		return clSetCommandQueueProperty(Pointer.getPeer(cl_command_queue1), cl_command_queue_properties1, cl_bool1, Pointer.getPeer(cl_command_queue_propertiesPtr1));
	}
	public native int clSetCommandQueueProperty(@Ptr long cl_command_queue1, long cl_command_queue_properties1, int cl_bool1, @Ptr long cl_command_queue_propertiesPtr1);
	/** Original signature : <code>cl_mem clCreateImage2D(cl_context, cl_mem_flags, const cl_image_format*, size_t, size_t, size_t, void*, cl_int*)</code> */
	public IOpenCLLibrary.cl_mem clCreateImage2D(IOpenCLLibrary.cl_context cl_context1, long cl_mem_flags1, Pointer<cl_image_format > cl_image_formatPtr1, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, Pointer<? > voidPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_mem(clCreateImage2D(Pointer.getPeer(cl_context1), cl_mem_flags1, Pointer.getPeer(cl_image_formatPtr1), size_t1, size_t2, size_t3, Pointer.getPeer(voidPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateImage2D(@Ptr long cl_context1, long cl_mem_flags1, @Ptr long cl_image_formatPtr1, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, @Ptr long voidPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_mem clCreateImage3D(cl_context, cl_mem_flags, const cl_image_format*, size_t, size_t, size_t, size_t, size_t, void*, cl_int*)</code> */
	public IOpenCLLibrary.cl_mem clCreateImage3D(IOpenCLLibrary.cl_context cl_context1, long cl_mem_flags1, Pointer<cl_image_format > cl_image_formatPtr1, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, @Ptr long size_t4, @Ptr long size_t5, Pointer<? > voidPtr1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_mem(clCreateImage3D(Pointer.getPeer(cl_context1), cl_mem_flags1, Pointer.getPeer(cl_image_formatPtr1), size_t1, size_t2, size_t3, size_t4, size_t5, Pointer.getPeer(voidPtr1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateImage3D(@Ptr long cl_context1, long cl_mem_flags1, @Ptr long cl_image_formatPtr1, @Ptr long size_t1, @Ptr long size_t2, @Ptr long size_t3, @Ptr long size_t4, @Ptr long size_t5, @Ptr long voidPtr1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clEnqueueMarker(cl_command_queue, cl_event*)</code> */
	public int clEnqueueMarker(IOpenCLLibrary.cl_command_queue cl_command_queue1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1) {
		return clEnqueueMarker(Pointer.getPeer(cl_command_queue1), Pointer.getPeer(cl_eventPtr1));
	}
	public native int clEnqueueMarker(@Ptr long cl_command_queue1, @Ptr long cl_eventPtr1);
	/** Original signature : <code>cl_int clEnqueueWaitForEvents(cl_command_queue, cl_uint, const cl_event*)</code> */
	public int clEnqueueWaitForEvents(IOpenCLLibrary.cl_command_queue cl_command_queue1, int cl_uint1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1) {
		return clEnqueueWaitForEvents(Pointer.getPeer(cl_command_queue1), cl_uint1, Pointer.getPeer(cl_eventPtr1));
	}
	public native int clEnqueueWaitForEvents(@Ptr long cl_command_queue1, int cl_uint1, @Ptr long cl_eventPtr1);
	/** Original signature : <code>cl_int clEnqueueBarrier(cl_command_queue)</code> */
	public int clEnqueueBarrier(IOpenCLLibrary.cl_command_queue cl_command_queue1) {
		return clEnqueueBarrier(Pointer.getPeer(cl_command_queue1));
	}
	public native int clEnqueueBarrier(@Ptr long cl_command_queue1);
	/** Original signature : <code>cl_int clUnloadCompiler()</code> */
	public native int clUnloadCompiler();
	/** Original signature : <code>void* clGetExtensionFunctionAddress(const char*)</code> */
	public Pointer<? > clGetExtensionFunctionAddress(Pointer<Byte > charPtr1) {
		return Pointer.pointerToAddress(clGetExtensionFunctionAddress(Pointer.getPeer(charPtr1)));
	}
	@Ptr 
	public native long clGetExtensionFunctionAddress(@Ptr long charPtr1);
	/**
	 * cl_gl_texture_info<br>
	 * Original signature : <code>cl_mem clCreateFromGLBuffer(cl_context, cl_mem_flags, cl_GLuint, int*)</code>
	 */
	public IOpenCLLibrary.cl_mem clCreateFromGLBuffer(IOpenCLLibrary.cl_context cl_context1, long cl_mem_flags1, int cl_GLuint1, Pointer<Integer > intPtr1) {
		return new IOpenCLLibrary.cl_mem(clCreateFromGLBuffer(Pointer.getPeer(cl_context1), cl_mem_flags1, cl_GLuint1, Pointer.getPeer(intPtr1)));
	}
	@Ptr 
	public native long clCreateFromGLBuffer(@Ptr long cl_context1, long cl_mem_flags1, int cl_GLuint1, @Ptr long intPtr1);
	/** Original signature : <code>cl_mem clCreateFromGLTexture(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int*)</code> */
	public IOpenCLLibrary.cl_mem clCreateFromGLTexture(IOpenCLLibrary.cl_context cl_context1, long cl_mem_flags1, int cl_GLenum1, int cl_GLint1, int cl_GLuint1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_mem(clCreateFromGLTexture(Pointer.getPeer(cl_context1), cl_mem_flags1, cl_GLenum1, cl_GLint1, cl_GLuint1, Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	@Optional 
	public native long clCreateFromGLTexture(@Ptr long cl_context1, long cl_mem_flags1, int cl_GLenum1, int cl_GLint1, int cl_GLuint1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_mem clCreateFromGLRenderbuffer(cl_context, cl_mem_flags, cl_GLuint, cl_int*)</code> */
	public IOpenCLLibrary.cl_mem clCreateFromGLRenderbuffer(IOpenCLLibrary.cl_context cl_context1, long cl_mem_flags1, int cl_GLuint1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_mem(clCreateFromGLRenderbuffer(Pointer.getPeer(cl_context1), cl_mem_flags1, cl_GLuint1, Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateFromGLRenderbuffer(@Ptr long cl_context1, long cl_mem_flags1, int cl_GLuint1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_int clGetGLObjectInfo(cl_mem, cl_gl_object_type*, cl_GLuint*)</code> */
	public int clGetGLObjectInfo(IOpenCLLibrary.cl_mem cl_mem1, Pointer<Integer > cl_gl_object_typePtr1, Pointer<Integer > cl_GLuintPtr1) {
		return clGetGLObjectInfo(Pointer.getPeer(cl_mem1), Pointer.getPeer(cl_gl_object_typePtr1), Pointer.getPeer(cl_GLuintPtr1));
	}
	public native int clGetGLObjectInfo(@Ptr long cl_mem1, @Ptr long cl_gl_object_typePtr1, @Ptr long cl_GLuintPtr1);
	/** Original signature : <code>cl_int clGetGLTextureInfo(cl_mem, cl_gl_texture_info, size_t, void*, size_t*)</code> */
	public int clGetGLTextureInfo(IOpenCLLibrary.cl_mem cl_mem1, int cl_gl_texture_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetGLTextureInfo(Pointer.getPeer(cl_mem1), cl_gl_texture_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	public native int clGetGLTextureInfo(@Ptr long cl_mem1, int cl_gl_texture_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/** Original signature : <code>cl_int clEnqueueAcquireGLObjects(cl_command_queue, cl_uint, const cl_mem*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueAcquireGLObjects(IOpenCLLibrary.cl_command_queue cl_command_queue1, int cl_uint1, Pointer<IOpenCLLibrary.cl_mem > cl_memPtr1, int cl_uint2, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueAcquireGLObjects(Pointer.getPeer(cl_command_queue1), cl_uint1, Pointer.getPeer(cl_memPtr1), cl_uint2, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueAcquireGLObjects(@Ptr long cl_command_queue1, int cl_uint1, @Ptr long cl_memPtr1, int cl_uint2, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_int clEnqueueReleaseGLObjects(cl_command_queue, cl_uint, const cl_mem*, cl_uint, const cl_event*, cl_event*)</code> */
	public int clEnqueueReleaseGLObjects(IOpenCLLibrary.cl_command_queue cl_command_queue1, int cl_uint1, Pointer<IOpenCLLibrary.cl_mem > cl_memPtr1, int cl_uint2, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr1, Pointer<IOpenCLLibrary.cl_event > cl_eventPtr2) {
		return clEnqueueReleaseGLObjects(Pointer.getPeer(cl_command_queue1), cl_uint1, Pointer.getPeer(cl_memPtr1), cl_uint2, Pointer.getPeer(cl_eventPtr1), Pointer.getPeer(cl_eventPtr2));
	}
	public native int clEnqueueReleaseGLObjects(@Ptr long cl_command_queue1, int cl_uint1, @Ptr long cl_memPtr1, int cl_uint2, @Ptr long cl_eventPtr1, @Ptr long cl_eventPtr2);
	/** Original signature : <code>cl_mem clCreateFromGLTexture2D(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int*)</code> */
	public IOpenCLLibrary.cl_mem clCreateFromGLTexture2D(IOpenCLLibrary.cl_context cl_context1, long cl_mem_flags1, int cl_GLenum1, int cl_GLint1, int cl_GLuint1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_mem(clCreateFromGLTexture2D(Pointer.getPeer(cl_context1), cl_mem_flags1, cl_GLenum1, cl_GLint1, cl_GLuint1, Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateFromGLTexture2D(@Ptr long cl_context1, long cl_mem_flags1, int cl_GLenum1, int cl_GLint1, int cl_GLuint1, @Ptr long cl_intPtr1);
	/** Original signature : <code>cl_mem clCreateFromGLTexture3D(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int*)</code> */
	public IOpenCLLibrary.cl_mem clCreateFromGLTexture3D(IOpenCLLibrary.cl_context cl_context1, long cl_mem_flags1, int cl_GLenum1, int cl_GLint1, int cl_GLuint1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_mem(clCreateFromGLTexture3D(Pointer.getPeer(cl_context1), cl_mem_flags1, cl_GLenum1, cl_GLint1, cl_GLuint1, Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	public native long clCreateFromGLTexture3D(@Ptr long cl_context1, long cl_mem_flags1, int cl_GLenum1, int cl_GLint1, int cl_GLuint1, @Ptr long cl_intPtr1);
	/**
	 * Additional cl_context_properties<br>
	 * Original signature : <code>cl_int clGetGLContextInfoKHR(const cl_context_properties*, cl_gl_context_info, size_t, void*, size_t*)</code>
	 */
	public int clGetGLContextInfoKHR(Pointer<SizeT > cl_context_propertiesPtr1, int cl_gl_context_info1, @Ptr long size_t1, Pointer<? > voidPtr1, Pointer<SizeT > size_tPtr1) {
		return clGetGLContextInfoKHR(Pointer.getPeer(cl_context_propertiesPtr1), cl_gl_context_info1, size_t1, Pointer.getPeer(voidPtr1), Pointer.getPeer(size_tPtr1));
	}
	@Optional 
	public native int clGetGLContextInfoKHR(@Ptr long cl_context_propertiesPtr1, int cl_gl_context_info1, @Ptr long size_t1, @Ptr long voidPtr1, @Ptr long size_tPtr1);
	/**
	 * cl_khr_gl_event  extension<br>
	 *  See section 9.9 in the OpenCL 1.1 spec for more information<br>
	 * Original signature : <code>cl_event clCreateEventFromGLsyncKHR(cl_context, cl_GLsync, cl_int*)</code>
	 */
	public IOpenCLLibrary.cl_event clCreateEventFromGLsyncKHR(IOpenCLLibrary.cl_context cl_context1, IOpenCLLibrary.cl_GLsync cl_GLsync1, Pointer<Integer > cl_intPtr1) {
		return new IOpenCLLibrary.cl_event(clCreateEventFromGLsyncKHR(Pointer.getPeer(cl_context1), Pointer.getPeer(cl_GLsync1), Pointer.getPeer(cl_intPtr1)));
	}
	@Ptr 
	@Optional 
	public native long clCreateEventFromGLsyncKHR(@Ptr long cl_context1, @Ptr long cl_GLsync1, @Ptr long cl_intPtr1);
	/**
	 * Memory object destruction<br>
	 * Apple extension for use to manage externally allocated buffers used with cl_mem objects with CL_MEM_USE_HOST_PTR<br>
	 * Registers a user callback function that will be called when the memory object is deleted and its resources <br>
	 * freed. Each call to clSetMemObjectCallbackFn registers the specified user callback function on a callback <br>
	 * stack associated with memobj. The registered user callback functions are called in the reverse order in <br>
	 * which they were registered. The user callback functions are called and then the memory object is deleted <br>
	 * and its resources freed. This provides a mechanism for the application (and libraries) using memobj to be <br>
	 * notified when the memory referenced by host_ptr, specified when the memory object is created and used as <br>
	 * the storage bits for the memory object, can be reused or freed.<br>
	 * The application may not call CL api's with the cl_mem object passed to the pfn_notify.<br>
	 * Please check for the "cl_APPLE_SetMemObjectDestructor" extension using clGetDeviceInfo(CL_DEVICE_EXTENSIONS)<br>
	 * before using.<br>
	 * memobj<br>
	 * Original signature : <code>cl_int clSetMemObjectDestructorAPPLE(cl_mem, clSetMemObjectDestructorAPPLE_arg1_callback*, void*)</code>
	 */
	public int clSetMemObjectDestructorAPPLE(IOpenCLLibrary.cl_mem cl_mem1, Pointer<OpenCLLibrary.clSetMemObjectDestructorAPPLE_arg1_callback > arg1, Pointer<? > voidPtr1) {
		return clSetMemObjectDestructorAPPLE(Pointer.getPeer(cl_mem1), Pointer.getPeer(arg1), Pointer.getPeer(voidPtr1));
	}
	@Optional 
	public native int clSetMemObjectDestructorAPPLE(@Ptr long cl_mem1, @Ptr long arg1, @Ptr long voidPtr1);
	/**
	 * Context Logging Functions<br>
	 * The next three convenience functions are intended to be used as the pfn_notify parameter to clCreateContext().<br>
	 * Please check for the "cl_APPLE_ContextLoggingFunctions" extension using clGetDeviceInfo(CL_DEVICE_EXTENSIONS)<br>
	 * before using.<br>
	 * clLogMessagesToSystemLog fowards on all log messages to the Apple System Logger<br>
	 * errstr<br>
	 * Original signature : <code>void clLogMessagesToSystemLogAPPLE(const char*, const void*, size_t, void*)</code>
	 */
	public void clLogMessagesToSystemLogAPPLE(Pointer<Byte > charPtr1, Pointer<? > voidPtr1, @Ptr long size_t1, Pointer<? > voidPtr2) {
		clLogMessagesToSystemLogAPPLE(Pointer.getPeer(charPtr1), Pointer.getPeer(voidPtr1), size_t1, Pointer.getPeer(voidPtr2));
	}
	@Optional 
	public native void clLogMessagesToSystemLogAPPLE(@Ptr long charPtr1, @Ptr long voidPtr1, @Ptr long size_t1, @Ptr long voidPtr2);
	/**
	 * clLogMessagesToStdout sends all log messages to the file descriptor stdout<br>
	 * errstr<br>
	 * Original signature : <code>void clLogMessagesToStdoutAPPLE(const char*, const void*, size_t, void*)</code>
	 */
	public void clLogMessagesToStdoutAPPLE(Pointer<Byte > charPtr1, Pointer<? > voidPtr1, @Ptr long size_t1, Pointer<? > voidPtr2) {
		clLogMessagesToStdoutAPPLE(Pointer.getPeer(charPtr1), Pointer.getPeer(voidPtr1), size_t1, Pointer.getPeer(voidPtr2));
	}
	@Optional 
	public native void clLogMessagesToStdoutAPPLE(@Ptr long charPtr1, @Ptr long voidPtr1, @Ptr long size_t1, @Ptr long voidPtr2);
	/**
	 * clLogMessagesToStderr sends all log messages to the file descriptor stderr<br>
	 * errstr<br>
	 * Original signature : <code>void clLogMessagesToStderrAPPLE(const char*, const void*, size_t, void*)</code>
	 */
	public void clLogMessagesToStderrAPPLE(Pointer<Byte > charPtr1, Pointer<? > voidPtr1, @Ptr long size_t1, Pointer<? > voidPtr2) {
		clLogMessagesToStderrAPPLE(Pointer.getPeer(charPtr1), Pointer.getPeer(voidPtr1), size_t1, Pointer.getPeer(voidPtr2));
	}
	@Optional 
	public native void clLogMessagesToStderrAPPLE(@Ptr long charPtr1, @Ptr long voidPtr1, @Ptr long size_t1, @Ptr long voidPtr2);
	/**
	 * Additional Error Codes<br>
	 * Original signature : <code>cl_int clIcdGetPlatformIDsKHR(cl_uint, cl_platform_id*, cl_uint*)</code>
	 */
	public int clIcdGetPlatformIDsKHR(int cl_uint1, Pointer<IOpenCLLibrary.cl_platform_id > cl_platform_idPtr1, Pointer<Integer > cl_uintPtr1) {
		return clIcdGetPlatformIDsKHR(cl_uint1, Pointer.getPeer(cl_platform_idPtr1), Pointer.getPeer(cl_uintPtr1));
	}
	@Optional 
	public native int clIcdGetPlatformIDsKHR(int cl_uint1, @Ptr long cl_platform_idPtr1, @Ptr long cl_uintPtr1);
	/** Original signature : <code>cl_int clReleaseDeviceEXT(cl_device_id)</code> */
	public int clReleaseDeviceEXT(IOpenCLLibrary.cl_device_id cl_device_id1) {
		return clReleaseDeviceEXT(Pointer.getPeer(cl_device_id1));
	}
	@Optional 
	public native int clReleaseDeviceEXT(@Ptr long cl_device_id1);
	/** Original signature : <code>cl_int clRetainDeviceEXT(cl_device_id)</code> */
	public int clRetainDeviceEXT(IOpenCLLibrary.cl_device_id cl_device_id1) {
		return clRetainDeviceEXT(Pointer.getPeer(cl_device_id1));
	}
	@Optional 
	public native int clRetainDeviceEXT(@Ptr long cl_device_id1);
	/** Original signature : <code>cl_int clCreateSubDevicesEXT(cl_device_id, const cl_device_partition_property_ext*, cl_uint, cl_device_id*, cl_uint*)</code> */
	public int clCreateSubDevicesEXT(IOpenCLLibrary.cl_device_id cl_device_id1, Pointer<Long > cl_device_partition_property_extPtr1, int cl_uint1, Pointer<IOpenCLLibrary.cl_device_id > cl_device_idPtr1, Pointer<Integer > cl_uintPtr1) {
		return clCreateSubDevicesEXT(Pointer.getPeer(cl_device_id1), Pointer.getPeer(cl_device_partition_property_extPtr1), cl_uint1, Pointer.getPeer(cl_device_idPtr1), Pointer.getPeer(cl_uintPtr1));
	}
	@Optional 
	public native int clCreateSubDevicesEXT(@Ptr long cl_device_id1, @Ptr long cl_device_partition_property_extPtr1, int cl_uint1, @Ptr long cl_device_idPtr1, @Ptr long cl_uintPtr1);
	/**
	 * Apple extension for retrieving OpenGL context information for a CL context <br>
	 * created via the above method.<br>
	 * Provides a query mechanism to retrieve OpenGL context specific information <br>
	 * from an OpenCL context to help identify device specific mappings and usage.<br>
	 * <br>
	 * For example, one possible usage would be to allow the client to map a CGL <br>
	 * virtual screen index to an appropriate CL device id to insure that the <br>
	 * rendering device and the compute device are the same, thus guaranteeing <br>
	 * any shared OpenGL memory that is attached o a CL memory object remains <br>
	 * resident on the active device.<br>
	 * context<br>
	 * Original signature : <code>cl_int clGetGLContextInfoAPPLE(cl_context, void*, cl_gl_platform_info, size_t, void*, size_t*)</code>
	 */
	public int clGetGLContextInfoAPPLE(IOpenCLLibrary.cl_context cl_context1, Pointer<? > voidPtr1, int cl_gl_platform_info1, @Ptr long size_t1, Pointer<? > voidPtr2, Pointer<SizeT > size_tPtr1) {
		return clGetGLContextInfoAPPLE(Pointer.getPeer(cl_context1), Pointer.getPeer(voidPtr1), cl_gl_platform_info1, size_t1, Pointer.getPeer(voidPtr2), Pointer.getPeer(size_tPtr1));
	}
	@Optional 
	public native int clGetGLContextInfoAPPLE(@Ptr long cl_context1, @Ptr long voidPtr1, int cl_gl_platform_info1, @Ptr long size_t1, @Ptr long voidPtr2, @Ptr long size_tPtr1);
}
